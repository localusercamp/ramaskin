import { resolveNitroPath, writeFile } from "nitropack/kit";

export default defineNitroModule({
    name: "routing",

    setup(nitro) {
        const { options } = nitro;
        const { buildDir, rootDir } = options;

        const filepath = resolveNitroPath("types/api.d.ts", options, buildDir);

        async function buildTypes(): Promise<void> {
            const api: Record<string, Record<string, unknown>> = {};

            for (const handler of nitro.scannedHandlers) {
                const route = handler.route;

                if (!route) {
                    continue;
                }

                const method = handler.method ?? "default";
                const path = "../.." + resolveNitroPath(handler.handler.replace(rootDir, ""), options, rootDir);
                const type = `Simplify<Serialize<Awaited<ReturnType<typeof import("${path}").default>>>>`;

                api[route] ||= {};

                api[route][method] = type;
            }

            const t = " ".repeat(4);
            const tt = t.repeat(2);

            const content = [
                `// Generated by ../..${__filename.replace(rootDir, "")}`,
                "import type { Serialize, Simplify } from \"nitropack/types\";",
                "",
                "type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T",
                "",
                "export interface Api {",
                Object.entries(api)
                    .map(([route, methods]) => [
                        `${t}'${route}': {`,
                        Object.entries(methods)
                            .map(([method, type]) => `${tt}'${method}': ${type}`)
                            .join("\n"),
                        `${t}}`,
                    ].join("\n"))
                    .join("\n"),
                "}",
            ].join("\n") + "\n";

            await writeFile(filepath, content);
        }

        nitro.hooks.hook("build:before", buildTypes);
        nitro.hooks.hook("dev:reload", buildTypes);
    },
});
